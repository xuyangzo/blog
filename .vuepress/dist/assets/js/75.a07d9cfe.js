(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{304:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"js-的垃圾回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-的垃圾回收机制","aria-hidden":"true"}},[t._v("#")]),t._v(" JS 的垃圾回收机制")]),t._v(" "),e("blockquote",[e("p",[t._v("Posted: 09.25.2019")])]),t._v(" "),e("Tag"),t._v(" "),e("h2",{attrs:{id:"简单描述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单描述","aria-hidden":"true"}},[t._v("#")]),t._v(" 简单描述")]),t._v(" "),e("p",[t._v("学过C++的人肯定知道，在分配内存后，需要手动去回收内存。")]),t._v(" "),e("p",[t._v("Java有垃圾收集器，这玩意儿会自动处理内存的回收。")]),t._v(" "),e("p",[t._v("JS也有。JS的垃圾回收机制一共有两种算法。")]),t._v(" "),e("h2",{attrs:{id:"标记清除算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 标记清除算法")]),t._v(" "),e("blockquote",[e("p",[t._v("从2012年起，所有现代浏览器都使用了标记清除垃圾回收算法")])]),t._v(" "),e("p",[t._v("该算法本质上就是广度遍历（或者深度遍历，结果是一样的）。")]),t._v(" "),e("p",[t._v("在每个周期内，做如下的工作：")]),t._v(" "),e("ol",[e("li",[t._v("从全局对象开始（对于浏览器来说是 window 对象，对于Node来说是 global 对象）")]),t._v(" "),e("li",[t._v("对全局对象使用广度遍历/深度遍历，从该对象开始，标记该对象，以及该对象可以访问到的对象")]),t._v(" "),e("li",[t._v("在遍历结束时，所有被引用的对象都被标记，而"),e("span",{staticStyle:{color:"palevioletred"}},[e("strong",[t._v("无法触达")])]),t._v("的对象则没有被标记")]),t._v(" "),e("li",[t._v("清除所有没有标记的对象")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/mark-sweep.png",alt:"mark and sweep"}})]),t._v(" "),e("p",[t._v("如果两个对象互相引用，而且没有其余指针指向它们，它们就无法被访问，因此会被清除，其占用的内存被释放。就像是上图的红圈。")]),t._v(" "),e("h2",{attrs:{id:"引用计数算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 引用计数算法")]),t._v(" "),e("blockquote",[e("p",[t._v("这是最初级的垃圾收集算法，存在着很重大的问题，因此目前已经被废弃了")])]),t._v(" "),e("p",[t._v("其核心是：跟踪记录每个值被引用的次数")]),t._v(" "),e("ul",[e("li",[t._v("当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1")]),t._v(" "),e("li",[t._v("相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1")]),t._v(" "),e("li",[t._v("当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存")])]),t._v(" "),e("p",[e("span",{staticStyle:{color:"palevioletred"}},[t._v("但是这样会出现互相引用的问题！！！")])]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[t._v("objA"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someOtherObject "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objB"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nobjB"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("anotherObject "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objA"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("如同上面的代码，objA 和 objB 相互引用，这意味着它们的引用次数永远不会为0。")]),t._v(" "),e("p",[t._v("而当 objA 和 objB 离开作用域，并且函数执行完成之后，它们还将会继续存在，因为它们的引用次数不为0，垃圾清理机制不会清除它们！！")]),t._v(" "),e("p",[t._v("于是，内存泄漏就出现了！！！")]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management",target:"_blank",rel:"noopener noreferrer"}},[t._v("Garbage collection"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://javascript.info/garbage-collection",target:"_blank",rel:"noopener noreferrer"}},[t._v("Garbage collection"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/zhwl/p/4664604.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript垃圾回收机制"),e("OutboundLink")],1)])],1)}),[],!1,null,null,null);a.default=s.exports}}]);