(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{346:function(a,t,e){"use strict";e.r(t);var r=e(1),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"js-的垃圾回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-的垃圾回收机制","aria-hidden":"true"}},[a._v("#")]),a._v(" JS 的垃圾回收机制")]),a._v(" "),e("blockquote",[e("p",[a._v("Posted: 09.25.2019")])]),a._v(" "),e("Tag"),a._v(" "),e("h2",{attrs:{id:"简单描述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单描述","aria-hidden":"true"}},[a._v("#")]),a._v(" 简单描述")]),a._v(" "),e("p",[a._v("学过C++的人肯定知道，在分配内存后，需要手动去回收内存。")]),a._v(" "),e("p",[a._v("Java有垃圾收集器，这玩意儿会自动处理内存的回收。")]),a._v(" "),e("p",[a._v("JS也有。JS的垃圾回收机制一共有两种算法。")]),a._v(" "),e("h2",{attrs:{id:"标记清除算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 标记清除算法")]),a._v(" "),e("blockquote",[e("p",[a._v("从2012年起，所有现代浏览器都使用了标记清除垃圾回收算法")])]),a._v(" "),e("p",[a._v("该算法本质上就是广度遍历（或者深度遍历，结果是一样的）。")]),a._v(" "),e("p",[a._v("在每个周期内，做如下的工作：")]),a._v(" "),e("ol",[e("li",[a._v("从全局对象开始（对于浏览器来说是 window 对象，对于Node来说是 global 对象）")]),a._v(" "),e("li",[a._v("对全局对象使用广度遍历/深度遍历，从该对象开始，标记该对象，以及该对象可以访问到的对象")]),a._v(" "),e("li",[a._v("在遍历结束时，所有被引用的对象都被标记，而"),e("span",{directives:[{name:"red",rawName:"v-red"}]},[e("strong",[a._v("无法触达")])]),a._v("的对象则没有被标记")]),a._v(" "),e("li",[a._v("清除所有没有标记的对象")])]),a._v(" "),e("p",[e("img",{attrs:{src:"/mark-sweep.png",alt:"mark and sweep"}})]),a._v(" "),e("p",[a._v("如果两个对象互相引用，而且没有其余指针指向它们，它们就无法被访问，因此会被清除，其占用的内存被释放。就像是上图的红圈。")]),a._v(" "),e("h2",{attrs:{id:"引用计数算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),e("blockquote",[e("p",[a._v("这是最初级的垃圾收集算法，存在着很重大的问题，因此目前已经被废弃了")])]),a._v(" "),e("p",[a._v("其核心是：跟踪记录每个值被引用的次数")]),a._v(" "),e("ul",[e("li",[a._v("当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1")]),a._v(" "),e("li",[a._v("相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1")]),a._v(" "),e("li",[a._v("当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存")])]),a._v(" "),e("p",[e("span",{directives:[{name:"red",rawName:"v-red"}]},[a._v("但是这样会出现互相引用的问题！！！")])]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[a._v("objA"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("someOtherObject "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" objB"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobjB"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("anotherObject "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" objA"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("p",[a._v("如同上面的代码，objA 和 objB 相互引用，这意味着它们的引用次数永远不会为0。")]),a._v(" "),e("p",[a._v("而当 objA 和 objB 离开作用域，并且函数执行完成之后，它们还将会继续存在，因为它们的引用次数不为0，垃圾清理机制不会清除它们！！")]),a._v(" "),e("p",[a._v("于是，内存泄漏就出现了！！！")]),a._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management",target:"_blank",rel:"noopener noreferrer"}},[a._v("Garbage collection"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://javascript.info/garbage-collection",target:"_blank",rel:"noopener noreferrer"}},[a._v("Garbage collection"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/zhwl/p/4664604.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript垃圾回收机制"),e("OutboundLink")],1)])],1)}),[],!1,null,null,null);t.default=s.exports}}]);